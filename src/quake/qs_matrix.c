#include "qs_matrix.h"
//would be really really cool to move this to a variable and do cool things with it as an effect
#define PI 3.14159

#include <string.h>
#include <math.h>
//this is shamelessly generated by chatgpt since i TRIED to make this work on my own and it just wouldnt work sorry
//im not a vibe coder i promise

void MatrixIdentity(mat4 m)
{
        memset(m, 0, sizeof(float) * 16);
        m[0] = m[5] = m[10] = m[15] = 1.0f;
}

void MatrixMultiply(mat4 out, const mat4 a, const mat4 b)
{
        float result[16];
        for (int i = 0; i < 4; ++i)
        {
                for (int j = 0; j < 4; ++j)
                {
                        result[i * 4 + j] = 0;
                        for (int k = 0; k < 4; ++k)
                        {
                                result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                        }
                }
        }
        memcpy(out, result, sizeof(result));
}

void MatrixTranslate(mat4 m, float x, float y, float z)
{
        float t[16];
        MatrixIdentity(t);
        t[12] = x;
        t[13] = y;
        t[14] = z;
        MatrixMultiply(m, m, t);
}

void MatrixRotate(mat4 m, float angle, float x, float y, float z)
{
        float rad = angle * (PI / 180.0f);
        float c = cosf(rad);
        float s = sinf(rad);
        float t[16];

        t[0] = x * x * (1 - c) + c;
        t[4] = x * y * (1 - c) - z * s;
        t[8] = x * z * (1 - c) + y * s;
        t[12] = 0;
        t[1] = y * x * (1 - c) + z * s;
        t[5] = y * y * (1 - c) + c;
        t[9] = y * z * (1 - c) - x * s;
        t[13] = 0;
        t[2] = z * x * (1 - c) - y * s;
        t[6] = z * y * (1 - c) + x * s;
        t[10] = z * z * (1 - c) + c;
        t[14] = 0;
        t[3] = 0;
        t[7] = 0;
        t[11] = 0;
        t[15] = 1;

        MatrixMultiply(m, m, t);
}

void MatrixRotate_OnePass(mat4 m, float x, float y, float z)
{
        mat4_t(rot);

        float pitch = x * (PI / 180.0f);
        float yaw = y * (PI / 180.0f);
        float roll = z * (PI / 180.0f);

        float cx = cosf(pitch), sx = sinf(pitch);
        float cy = cosf(yaw), sy = sinf(yaw);
        float cz = cosf(roll), sz = sinf(roll);
        MatrixIdentity(rot);
    
        rot[0]  = cy * cz;
        rot[1]  = -cy * sz;
        rot[2]  = sy;
        rot[4]  = sx * sy * cz + cx * sz;
        rot[5]  = -sx * sy * sz + cx * cz;
        rot[6]  = -sx * cy;
        rot[8]  = -cx * sy * cz + sx * sz;
        rot[9]  = cx * sy * sz + sx * cz;
        rot[10] = cx * cy;

        //matrix multiplication is confusign me
        mat4_t(temp1);
        memcpy(temp1,m,sizeof(float)*16);
        MatrixMultiply(m, temp1, rot);
}

void MatrixSetFrustum(mat4 m, float fovX, float fovY)
{
        // Compute frustum projection matrix (simplified perspective projection)
        float aspect = fovX / fovY;
        float near = 0.1f;
        float far = 66600.0f;
        float f = 1.0f / tan(fovY * 0.5f * (PI / 180.0f));

        m[0] = f / aspect;
        m[5] = f;
        m[10] = (far + near) / (near - far);
        m[11] = -1.0f;
        m[14] = (2.0f * far * near) / (near - far);
        m[15] = 0.0f;
}

void MatrixSetFrustum_AspectFOV(mat4 m, float aspect,float fov)
{
        float fovx = fov;
        float fovy = fov / aspect;
        MatrixSetFrustum(m,fovx,fovy);
}

void MatrixScale(mat4 m, float sx, float sy, float sz) {
        float s[16];
        MatrixIdentity(s);
        s[0] = sx;
        s[5] = sy;
        s[10] = sz;
        MatrixMultiply(m, m, s);
    }